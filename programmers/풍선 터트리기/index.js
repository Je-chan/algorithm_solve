/**
 * 풍선이 마지막까지 남을 수 있는지 판단하는 로직:
 * 1. 양쪽에서 더 작은 수를 한 번씩 터트릴 수 있음
 * 2. 해당 풍선이 양쪽의 최솟값들보다 모두 크면 살아남을 수 없음
 *
 * @param {number[]} a - 풍선들의 번호가 담긴 배열
 * @returns {number} - 마지막까지 남을 수 있는 풍선의 개수
 */
function solution(a) {
  // 길이가 2 이하면 모든 풍선이 마지막까지 남을 수 있음
  if (a.length <= 2) return a.length;

  const n = a.length;
  // 각 위치별로 왼쪽과 오른쪽의 최솟값을 저장할 배열
  const leftMin = new Array(n).fill(0); // 왼쪽부터 i까지의 최솟값 [9, 9, 9]
  const rightMin = new Array(n).fill(0); // i부터 오른쪽까지의 최솟값 [-5, -5, -5]

  // 왼쪽에서부터의 최솟값을 계산
  // leftMin[i]는 0부터 i-1까지의 최솟값
  leftMin[0] = a[0];
  for (let i = 1; i < n; i++) {
    leftMin[i] = Math.min(leftMin[i - 1], a[i - 1]);
  }

  // 오른쪽에서부터의 최솟값을 계산
  // rightMin[i]는 i+1부터 끝까지의 최솟값
  rightMin[n - 1] = a[n - 1];
  for (let i = n - 2; i >= 0; i--) {
    rightMin[i] = Math.min(rightMin[i + 1], a[i + 1]);
  }

  let count = 0;
  // 각 풍선이 마지막까지 남을 수 있는지 확인
  for (let i = 0; i < n; i++) {
    // 맨 왼쪽과 맨 오른쪽 풍선은 항상 가능
    // - 맨 왼쪽: 오른쪽의 큰 수들을 모두 터트리면 됨
    // - 맨 오른쪽: 왼쪽의 큰 수들을 모두 터트리면 됨
    if (i === 0 || i === n - 1) {
      count++;
      continue;
    }

    // 현재 풍선이 양쪽의 최솟값보다 모두 크면
    // 작은 수를 두 번 터트려야만 현재 풍선을 터트릴 수 있음
    // (규칙상 불가능하므로 이 풍선은 살아남을 수 없음)
    if (a[i] > leftMin[i] && a[i] > rightMin[i]) {
      continue;
    }

    // 그 외의 경우는 모두 가능
    // - 왼쪽 최솟값보다 작거나 같으면: 왼쪽의 큰 수들을 먼저 터트림
    // - 오른쪽 최솟값보다 작거나 같으면: 오른쪽의 큰 수들을 먼저 터트림
    count++;
  }

  return count;
}

console.log(solution([9, -1, -5])); // 3
/**
 * 예시로 설명: a = [9, -1, -5]
 * 1. leftMin:  [9, 9, -1]   // 왼쪽부터의 최솟값
 * 2. rightMin: [-5, -5, -5] // 오른쪽부터의 최솟값
 *
 * 각 위치별 분석:
 * - 9 (idx=0): 맨 왼쪽이므로 가능
 * - -1 (idx=1): 오른쪽 최솟값(-5)보다 크지만, 왼쪽 최솟값(9)보다 작음 -> 가능
 * - -5 (idx=2): 맨 오른쪽이므로 가능
 *
 * 따라서 3개의 풍선 모두 마지막까지 남을 수 있음 -> return 3
 */

/**
 * 입력 배열: [-16, 27, 65, -2, 58, -92, -71, -68, -61, -33]
 *
 * 1. leftMin 배열 계산 (왼쪽에서부터의 최솟값):
 * [-16, -16, -16, -16, -16, -16, -16, -16, -16, -16]
 *
 * 2. rightMin 배열 계산 (오른쪽에서부터의 최솟값):
 * [-92, -92, -92, -92, -92, -92, -71, -68, -61, -33]
 *
 * 3. 각 풍선의 생존 가능성 분석:
 *
 * [-16] (idx=0): 맨 왼쪽이므로 무조건 생존 가능
 * => count = 1
 *
 * [27] (idx=1):
 * - leftMin[1] = -16, rightMin[1] = -92
 * - 양쪽 모두의 최솟값보다 큼 -> 생존 불가능
 * => count = 1
 *
 * [65] (idx=2):
 * - leftMin[2] = -16, rightMin[2] = -92
 * - 양쪽 모두의 최솟값보다 큼 -> 생존 불가능
 * => count = 1
 *
 * [-2] (idx=3):
 * - leftMin[3] = -16, rightMin[3] = -92
 * - 왼쪽 최솟값(-16)보다 크지만, 오른쪽 최솟값(-92)보다 작음 -> 생존 가능
 * => count = 2
 *
 * [58] (idx=4):
 * - leftMin[4] = -16, rightMin[4] = -92
 * - 양쪽 모두의 최솟값보다 큼 -> 생존 불가능
 * => count = 2
 *
 * [-92] (idx=5):
 * - leftMin[5] = -16, rightMin[5] = -92
 * - 왼쪽 최솟값(-16)보다 작음 -> 생존 가능
 * => count = 3
 *
 * [-71] (idx=6):
 * - leftMin[6] = -16, rightMin[6] = -71
 * - 왼쪽 최솟값(-16)보다 작음 -> 생존 가능
 * => count = 4
 *
 * [-68] (idx=7):
 * - leftMin[7] = -16, rightMin[7] = -68
 * - 왼쪽 최솟값(-16)보다 작음 -> 생존 가능
 * => count = 5
 *
 * [-61] (idx=8):
 * - leftMin[8] = -16, rightMin[8] = -61
 * - 왼쪽 최솟값(-16)보다 작음 -> 생존 가능
 * => count = 6
 *
 * [-33] (idx=9): 맨 오른쪽이므로 무조건 생존 가능
 * => 최종 count = 6
 */
