function bellmanFord(n, edges, start) {
	// -------------------------------------------------------
	// 1. 거리 배열 초기화
	// -------------------------------------------------------
	// dist[i]는 "start에서 i까지 가는 현재까지의 최소 비용"을 의미합니다.
	// 처음에는 아무 경로도 모르기 때문에 모두 Infinity로 초기화합니다.
	// 단, 시작점은 자기 자신까지의 거리가 0입니다.
	// -------------------------------------------------------

	const dist = Array(n + 1).fill(Infinity);
	dist[start] = 0;

	// -------------------------------------------------------
	// 2️. 핵심 로직: n-1번 반복
	// -------------------------------------------------------
	// 왜 n-1번인가?
	// 노드가 n개라면, 최단 경로는 최대 n-1개의 간선을 사용할 수 있기 때문입니다.
	// (n개 이상 사용하면 반드시 사이클이 생기므로 최단 경로가 될 수 없습니다.)
	//
	// 이 반복은 "최단 거리 정보를 점점 퍼뜨리는 과정"입니다.
	//
	// 1번째 반복 → 간선 1개 사용하는 경로 반영
	// 2번째 반복 → 간선 2개 사용하는 경로 반영
	// ...
	// n-1번째 반복 → 최대 길이 n-1 경로까지 반영 완료
	// -------------------------------------------------------

	for (let i = 1; i <= n - 1; i++) {
		// 모든 간선을 하나씩 확인합니다.
		// edges 배열은 [출발노드, 도착노드, 가중치] 형태입니다.
		for (const [u, v, w] of edges) {
			// ---------------------------------------------------
			// 3. 완화(Relaxation) 과정
			// ---------------------------------------------------
			// "u를 거쳐 v로 가는 것이 더 짧은가?"를 확인합니다.
			//
			// dist[u] !== Infinity:
			//   → u까지 도달 가능한 경우만 고려합니다.
			//
			// dist[v] > dist[u] + w:
			//   → 현재 알고 있는 v까지 거리보다
			//     u를 거쳐가는 경로가 더 짧으면 갱신합니다.
			//
			// 이 한 줄이 벨만-포드의 핵심입니다.
			// ---------------------------------------------------

			if (dist[u] !== Infinity && dist[v] > dist[u] + w) {
				dist[v] = dist[u] + w;
			}
		}
	}

	// -------------------------------------------------------
	// 4️⃣ 음수 사이클 검사
	// -------------------------------------------------------
	// n-1번 반복이 끝났다면,
	// "최단 거리"는 모두 확정되어 있어야 합니다.
	//
	// 그런데 한 번 더 돌렸는데 값이 줄어든다면?
	//
	// → n개 이상의 간선을 사용했다는 뜻
	// → 즉, 사이클을 사용했다는 뜻
	// → 그런데 줄어들었다?
	// → 음수 사이클 존재
	//
	// 음수 사이클이 존재하면
	// 최단 거리는 정의되지 않습니다 (무한히 작아질 수 있음)
	// -------------------------------------------------------

	for (const [u, v, w] of edges) {
		if (dist[u] !== Infinity && dist[v] > dist[u] + w) {
			return 'Negative Cycle Exists';
		}
	}

	// -------------------------------------------------------
	// 5️⃣ 최종 결과 반환
	// -------------------------------------------------------
	// start에서 각 노드까지의 최단 거리 배열 반환
	// -------------------------------------------------------

	return dist;
}
